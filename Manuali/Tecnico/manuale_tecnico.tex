\documentclass[10pt, a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{graphicx} 
\graphicspath{{images/}}
\usepackage{float}    
\usepackage{geometry} 
\usepackage{xcolor}   
\usepackage{listings} 
\usepackage{hyperref} 

\geometry{top=1.5cm, bottom=1.5cm, left=1.5cm, right=1.5cm}

\definecolor{javared}{rgb}{0.6,0,0} 
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} 
\definecolor{javapurple}{rgb}{0.5,0,0.35} 
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} 

\lstset{
	language=Java,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{javapurple}\bfseries,
	stringstyle=\color{javared},
	commentstyle=\color{javagreen},
	morecomment=[s][\color{javadocblue}]{/**}{*/},
	frame=single,
	breaklines=true,
	numbers=left,
	numberstyle=\tiny\color{gray},
	captionpos=b,
	showstringspaces=false,
	tabsize=4,
	extendedchars=true,
	inputencoding=utf8
}

\lstdefinestyle{sqlstyle}{
	language=SQL,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{javapurple}\bfseries,
	stringstyle=\color{javared},
	commentstyle=\color{javagreen},
	morecomment=[l][\color{javadocblue}]{--},
	frame=single,
	breaklines=true,
	numbers=left,
	numberstyle=\tiny\color{gray},
	captionpos=b,
	showstringspaces=false,
	tabsize=4,
	extendedchars=true,
	literate={à}{{\`a}}1 {è}{{\`e}}1 {é}{{\'e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1 {À}{{\`A}}1 {È}{{\`E}}1 {É}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
}

\title{\textbf{Documentazione di Progetto}\\Manuale Tecnico}
\author{
	\textbf{Book Recommender} \\ \\
	Lorenzo Monachino - 757393 - VA \\
	Lyan Curcio - 757579 - VA \\
	Sergio Saldarriaga - 757394 - VA\\
	Nash Guizzardi - 756941 - VA
}
\date{Anno Accademico 2024/2025}

\begin{document}
	
	\maketitle
	
	\tableofcontents
	\newpage
	
	% CAPITOLO 1
	\chapter{Progettazione della Soluzione}
	
	Questo capitolo illustra le scelte progettuali effettuate per la realizzazione del sistema \textit{Book Recommender}. L'analisi copre l'architettura software distribuita, definita tramite UML, e la progettazione della base di dati relazionale, con particolare attenzione ai vincoli di integrità e alla sicurezza.
	
	\section{Progettazione Software (UML)}
	L'architettura del sistema segue il pattern Client-Server e sfrutta la tecnologia Java RMI per la comunicazione remota. Il progetto è organizzato in quattro moduli logici (Maven Modules), ognuno con responsabilità specifiche.
	
	\subsection{Struttura Statica (Class Diagram)}
	Il diagramma delle classi (Figura \ref{fig:class_diagram}) mostra la suddivisione dei componenti e le dipendenze tra i pacchetti.
	
\begin{figure}[htbp]
	\centering
	\caption{Diagramma delle Classi: Architettura Completa del Sistema}
	\includegraphics[width=0.8\textwidth, keepaspectratio]{class_diagram_3.pdf}
	\label{fig:class_diagram}
\end{figure}
	
	\subsubsection{Modulo Common}
	È il pacchetto condiviso che definisce le regole di comunicazione.
	\begin{itemize}
		\item \textbf{Interfacce RMI:} 
		\begin{itemize}
			\item \texttt{BookRepositoryService}: Interfaccia pubblica per utenti non autenticati (ricerca, login, registrazione).
			\item \texttt{AuthedBookRepositoryService}: Interfaccia protetta per utenti autenticati, ottenibile solo post-login.
		\end{itemize}
		\item \textbf{DTO (Data Transfer Objects):} Classi immutabili (\texttt{Libri}, \texttt{UtentiRegistrati}, \texttt{Valutazione}) usate per il trasporto dati. Implementano \texttt{Serializable} per la trasmissione RMI.
		\item \textbf{Enums:} Definiscono una serie di "eventi" per gestire gli esiti senza ricorrere alle eccezioni per la logica di controllo.
	\end{itemize}
	
	\subsubsection{Modulo Server (Back-end)}
	Gestisce la logica applicativa e la persistenza.
	\begin{itemize}
		\item \textbf{Gestione Sessione (tramite Factory Pattern):} \texttt{BookRepositoryImpl} (in caso di autenticazione) agisce da Factory. I metodi \texttt{register} e \texttt{login} restituiscono un'istanza di \texttt{AuthedBookRepositoryImpl} specifica per l'utente, incapsulando l'\texttt{userId} nella sessione.
		\item \textbf{Database Manager:} Implementa il pattern Singleton per centralizzare la gestione della connessione JDBC.
		\item \textbf{Queries:} Classi statiche (\texttt{AuthQueries}, \texttt{LibraryQueries}, ecc.) che isolano le query SQL dal codice RMI.
	\end{itemize}
	
	\subsubsection{Modulo Client (Front-end)}
	Applicazione JavaFX basata sul pattern MVC.
	\begin{itemize}
		\item \textbf{Navigazione:} La classe \texttt{App} (Singleton) gestisce lo \texttt{Stage} primario e il cambio delle scene (\texttt{changeScene}).
		\item \textbf{Controller:} Classi come \texttt{LoginController} e \texttt{BenController} gestiscono l'interazione UI e invocano i metodi remoti.
	\end{itemize}
	
	\subsection{Struttura Dinamica (Sequence Diagrams)}
	Viene analizzato lo scenario critico di autenticazione per evidenziare la gestione della sicurezza.
	
\begin{figure}[htbp] 
	\centering
	\caption{Sequence Diagram: Login e creazione Sessione}
	\includegraphics[width=0.8\textwidth, keepaspectratio]{login_sequence_2.pdf}
	\label{fig:seq_login}
\end{figure}
	
	Come mostrato in Figura \ref{fig:seq_login}, il Client invoca \texttt{login()}. Il Server delega la verifica hash a \texttt{AuthQueries}. Se valida, viene istanziato un oggetto remoto di sessione che viene restituito al Client all'interno di un oggetto \texttt{BRPair}.
	
	\subsubsection{Sequence Diagram: Inserimento Suggerimento}
	Il seguente diagramma (Figura \ref{fig:seq_suggestion}) mostra il flusso per l'inserimento di un consiglio tra libri.
	
\begin{figure}[htbp]
	\centering
	\caption{Sequence Diagram: Logica di validazione inserimento suggerimento}
	\includegraphics[width=0.8\textwidth,keepaspectratio]{suggest_sequence_2.pdf}
	\label{fig:seq_suggestion}
\end{figure}
	
	\chapter{Progettazione Database}
	Il livello dati è gestito da PostgreSQL. La progettazione include vincoli per garantire la coerenza dei dati.
	
	\section{Analisi dei Requisiti}
	In conformità con le specifiche di progetto, il sistema è stato progettato per soddisfare requisiti funzionali distinti per tipologia di utenza e requisiti non funzionali vincolanti per l'architettura.
	
	\subsection{Requisiti Funzionali}
	Il sistema prevede due livelli di accesso con funzionalità incrementali:
	
	\begin{itemize}
		\item \textbf{Utente Non Registrato:}
		\begin{itemize}
			\item \textbf{Registrazione:} Inserimento dati anagrafici (Nome, Cognome, CF, Email, UserID, Password) per creare un nuovo account.
			\item \textbf{Login:} Autenticazione tramite UserID e Password.
			\item \textbf{Consultazione:} Ricerca di libri per titolo, autore o autore e anno di pubblicazione. Visualizzazione dei dettagli del libro.
		\end{itemize}
		
		\item \textbf{Utente Registrato:}
		Possiede tutte le funzionalità dell'ospite, con l'aggiunta di:
		\begin{itemize}
			\item \textbf{Gestione Librerie:} Creazione di librerie personali personalizzate; aggiunta e rimozione di libri dalle proprie librerie.
			\item \textbf{Valutazioni:} Inserimento di recensioni composte da punteggi (Stile, Contenuto, Gradevolezza, Originalità, Edizione) e note testuali per i libri posseduti.
			\item \textbf{Suggerimenti:} Possibilità di consigliare un libro correlato a un altro, a patto di possederli entrambi nelle proprie librerie.
		\end{itemize}
	\end{itemize}
	
	\subsection{Requisiti Non Funzionali e Vincoli di Sistema}
	\begin{itemize}
		\item \textbf{Architettura:} Client-Server distribuita basata su Java RMI.
		\item \textbf{Persistenza:} Utilizzo di database relazionale PostgreSQL.
		\item \textbf{Concorrenza:} Gestione di accessi multipli e contemporanei al server.
		\item \textbf{Interfaccia:} GUI realizzata con JavaFX.
	\end{itemize}
	
	\subsection{Vincoli di Integrità dei Dati}
	Oltre ai requisiti funzionali, sono stati implementati vincoli rigidi a livello di database per garantire la consistenza semantica dei dati:
	
	\begin{enumerate}
		\item \textbf{Unicità Utente:} Non è possibile registrare più utenti con lo stesso \texttt{UserID}, \texttt{Email} o \texttt{Codice Fiscale}.
		\item \textbf{Unicità Librerie:} Un utente non può creare due librerie con lo stesso nome.
		\item \textbf{Regola di Valutazione:} Un utente può inserire una valutazione per un libro \textit{solo se} tale libro è presente in almeno una delle sue librerie personali (gestito tramite Trigger).
		\item \textbf{Singola Valutazione:} Un utente non può valutare lo stesso libro più di una volta.
		\item \textbf{Regola dei Consigli:} Per suggerire un libro $B$ a chi ha letto $A$, l'utente deve possedere \textit{entrambi} i libri nelle proprie librerie (gestito tramite Trigger).
	\end{enumerate}
	
	\section{Schemi Database}
	\subsection{Shema Entity-Relationship (ER)}
	\begin{figure}[htbp]
		\centering
		\caption{Schema Entity-Relationship}
		\includegraphics[width=0.8\textwidth, keepaspectratio]{er_diagram_3.pdf}
		\label{fig:er_diagram}
	\end{figure}
	
	Le entità principali (Figura \ref{fig:er_diagram}) sono:
	\begin{itemize}
		\item \textbf{Utente:} Contiene le credenziali e l'hash della password.
		\item \textbf{Libro:} Catalogo statico importato da dataset CSV.
		\item \textbf{Libreria:} Gestiscono le librerie utente.
	\end{itemize}
	
	\subsection{Transizione dal Modello ER al Modello Relazionale}
	Nel passaggio dal modello concettuale (Diagramma ER) allo schema logico relazionale (SQL), le entità sono state tradotte in tabelle e le associazioni complesse hanno subito un processo di "reificazione", trasformandosi a loro volta in tabelle fisiche.
	
	\begin{itemize}
		\item \textbf{Associazione "Contiene" (Molti-a-Molti):} La relazione tra \textit{Librerie} e \textit{Libri} presenta cardinalità N:M. Nel modello relazionale, questo vincolo strutturale impone la creazione di una tabella ponte ("bridge table") denominata \textbf{LibriXLibrerie}. Essa contiene le chiavi esterne verso le due entità collegate; la chiave primaria della tabella è costituita dalla chiave composta (\textit{libreria\_id}, \textit{libro\_id}).
		
		\item \textbf{Associazione "Valuta" con attributi:} Sebbene concettualmente definita come relazione tra \textit{Utente} e \textit{Libro}, questa associazione possiede numerosi attributi propri (punteggi parziali e note testuali). Pertanto, è stata tradotta nella tabella \textbf{ValutazioniLibri}.
		
		\item \textbf{Associazione "Consiglia" (Ternaria):} Questa relazione coinvolge tre entità logiche: l'Utente (autore del consiglio), il Libro Sorgente e il Libro Consigliato. Nello schema logico si traduce nella tabella \textbf{ConsigliLibri}, dove tre chiavi esterne garantiscono l'integrità referenziale.
	\end{itemize}
	
	\subsection{Analisi delle Cardinalità e Vincoli}
	Le cardinalità definiscono i vincoli di partecipazione e molteplicità delle relazioni:
	
	\begin{itemize}
		\item \textbf{Utente - Libreria (1:N):} Un singolo utente può creare molteplici librerie ($N$), ma ogni libreria appartiene univocamente a un solo utente ($1$). Esiste un vincolo di integrità referenziale forte: la cancellazione dell'utente comporta la cancellazione a cascata (\textit{ON DELETE CASCADE}) di tutte le sue librerie.
		
		\item \textbf{Libreria - Libro (M:N):} Una libreria può contenere un numero arbitrario di libri e uno stesso libro può essere catalogato nelle librerie di diversi utenti.
		
		\item \textbf{Utente - Valutazione (1:N):} Un utente può redigere molte recensioni. Tuttavia, vige un vincolo di unicità sulla coppia (\textit{userid}, \textit{libro\_id}), che impedisce l'inserimento di valutazioni multiple per il medesimo libro da parte dello stesso utente.
	\end{itemize}
	
	\subsection{Schema Logico Relazionale}
	Di seguito viene riportato lo schema logico delle tabelle implementate nel database PostgreSQL. Sono evidenziate le chiavi primarie (sottolineate) e le chiavi esterne (FK).
	
	\begin{itemize}
		\item \textbf{UtentiRegistrati}(\underline{userid}: VARCHAR(50), nome: VARCHAR(50), cognome: VARCHAR(50), codice\_fiscale: CHAR(16) UNIQUE, email: VARCHAR(100) UNIQUE, password\_hash: VARCHAR(256))
		
		\item \textbf{Libri}(\underline{id}: SERIAL, titolo: VARCHAR(500), autori: VARCHAR(500), anno\_pubblicazione: INT, editore: VARCHAR(200), categorie: VARCHAR(200))
		
		\item \textbf{Librerie}(\underline{id}: SERIAL, nome: VARCHAR(100), \textit{userid}: VARCHAR(50) FK) \\
		\textit{Vincolo Unique: (nome, userid)}
		
		\item \textbf{LibriXLibrerie}(\underline{\textit{libreria\_id}: INT FK, \textit{libro\_id}: INT FK})
		
		\item \textbf{ValutazioniLibri}(\underline{id}: SERIAL, \textit{userid}: VARCHAR(50) FK, \textit{libro\_id}: INT FK, stile: INT, contenuto: INT, gradevolezza: INT, originalita: INT, edizione: INT, finale: INT\footnote{Attributo calcolato (Generated Column).}, note\_stile: VARCHAR(256), note\_contenuto: VARCHAR(256), note\_gradevolezza: VARCHAR(256), note\_originalita: VARCHAR(256), note\_edizione: VARCHAR(256), note\_finale: VARCHAR(256)) \\
		\textit{Vincolo Unique: (userid, libro\_id)}
		
		\item \textbf{ConsigliLibri}(\underline{id}: SERIAL, \textit{userid}: VARCHAR(50) FK, \textit{libro\_sorgente\_id}: INT FK, \textit{libro\_consigliato\_id}: INT FK) \\
		\textit{Vincolo Unique: (userid, libro\_sorgente\_id, libro\_consigliato\_id)}
	\end{itemize}
	
	\section{Script SQL}
	\subsection{Creazione Database}
	
	Di seguito viene riportato il codice sorgente completo (DDL) per la creazione del database PostgreSQL. Lo script include la definizione delle tabelle, i vincoli di integrità referenziale e i trigger PL/pgSQL necessari per implementare le regole di business (gestione dei consigli e delle valutazioni).
	
	\begin{lstlisting}[style=sqlstyle, caption=Script completo creazione Database Book Recommender]
		-- =============================================================================
		-- Script di creazione database Book Recommender (Lab B)
		-- =============================================================================
		
		-- Pulizia preliminare
		DROP TABLE IF EXISTS consigli CASCADE;
		DROP TABLE IF EXISTS valutazioni CASCADE;
		DROP TABLE IF EXISTS libri_x_librerie CASCADE;
		DROP TABLE IF EXISTS librerie CASCADE;
		DROP TABLE IF EXISTS utenti CASCADE;
		DROP TABLE IF EXISTS libri CASCADE;
		
		DROP TABLE IF EXISTS "ConsigliLibri" CASCADE;
		DROP TABLE IF EXISTS "ValutazioniLibri" CASCADE;
		DROP TABLE IF EXISTS "LibriXLibrerie" CASCADE;
		DROP TABLE IF EXISTS "Librerie" CASCADE;
		DROP TABLE IF EXISTS "UtentiRegistrati" CASCADE;
		DROP TABLE IF EXISTS "Libri" CASCADE;
		
		-- =============================================================================
		-- Tabella UtentiRegistrati
		-- Contiene i dati degli utenti che si registrano all'applicazione.
		-- =============================================================================
		CREATE TABLE "UtentiRegistrati" (
		userid          VARCHAR(50) PRIMARY KEY, -- UserID scelto dall'utente
		nome            VARCHAR(50) NOT NULL,
		cognome         VARCHAR(50) NOT NULL,
		codice_fiscale  CHAR(16) NOT NULL UNIQUE,
		email           VARCHAR(100) NOT NULL UNIQUE,
		password_hash   VARCHAR(256) NOT NULL
		);
		
		-- =============================================================================
		-- Tabella Libri
		-- Repository dei libri importati dal dataset CSV.
		-- =============================================================================
		CREATE TABLE "Libri" (
		id                  SERIAL PRIMARY KEY,     -- ID autogenerato
		titolo              VARCHAR(500) NOT NULL,
		autori              VARCHAR(500) NOT NULL,
		anno_pubblicazione  INTEGER NOT NULL,
		editore             VARCHAR(200),
		categorie           VARCHAR(200)
		);
		
		-- =============================================================================
		-- Tabella Librerie
		-- Rappresenta le raccolte create dagli utenti.
		-- =============================================================================
		CREATE TABLE "Librerie" (
		id      SERIAL PRIMARY KEY,
		nome    VARCHAR(100) NOT NULL,
		userid  VARCHAR(50) NOT NULL,
		
		-- Vincolo: Se un utente viene cancellato, le sue librerie vengono cancellate
		CONSTRAINT fk_utente_libreria
		FOREIGN KEY (userid) REFERENCES "UtentiRegistrati"(userid)
		ON DELETE CASCADE,
		
		-- Vincolo: Un utente non puo avere due librerie con lo stesso nome
		CONSTRAINT unique_nome_userid UNIQUE(nome, userid)
		);
		
		-- =============================================================================
		-- Tabella LibriXLibrerie (Relazione Molti-a-Molti)
		-- Collega i Libri alle Librerie. Un libro puo stare in piu librerie.
		-- =============================================================================
		CREATE TABLE "LibriXLibrerie" (
		libreria_id INTEGER NOT NULL,
		libro_id    INTEGER NOT NULL,
		
		PRIMARY KEY (libreria_id, libro_id),
		
		CONSTRAINT fk_libreria
		FOREIGN KEY (libreria_id) REFERENCES "Librerie"(id)
		ON DELETE RESTRICT, -- RESTRICT perche gestito da un trigger
		
		CONSTRAINT fk_libro
		FOREIGN KEY (libro_id) REFERENCES "Libri"(id)
		ON DELETE CASCADE
		);
		
		-- =============================================================================
		-- Tabella ValutazioniLibri
		-- Contiene i voti (1-5) e le note (max 256 char) per ogni criterio.
		-- =============================================================================
		CREATE TABLE "ValutazioniLibri" (
		id          SERIAL PRIMARY KEY,
		userid      VARCHAR(50) NOT NULL,
		libro_id    INTEGER NOT NULL,
		
		-- Punteggi (Scala 1-5)
		stile           INTEGER NOT NULL CHECK (stile BETWEEN 1 AND 5),
		contenuto       INTEGER NOT NULL CHECK (contenuto BETWEEN 1 AND 5),
		gradevolezza    INTEGER NOT NULL CHECK (gradevolezza BETWEEN 1 AND 5),
		originalita     INTEGER NOT NULL CHECK (originalita BETWEEN 1 AND 5),
		edizione        INTEGER NOT NULL CHECK (edizione BETWEEN 1 AND 5),
		finale          INTEGER GENERATED ALWAYS AS (
		ROUND((stile + contenuto + gradevolezza + originalita + edizione) / 5.0 )
		) STORED,
		
		-- Note opzionali
		note_stile          VARCHAR(256),
		note_contenuto      VARCHAR(256),
		note_gradevolezza   VARCHAR(256),
		note_originalita    VARCHAR(256),
		note_edizione       VARCHAR(256),
		note_finale         VARCHAR(256),
		
		-- Vincolo: Un utente puo valutare lo stesso libro una sola volta
		CONSTRAINT unique_valutazione_utente_libro UNIQUE (userid, libro_id),
		
		CONSTRAINT fk_valutazione_utente
		FOREIGN KEY (userid) REFERENCES "UtentiRegistrati"(userid)
		ON DELETE CASCADE,
		
		CONSTRAINT fk_valutazione_libro
		FOREIGN KEY (libro_id) REFERENCES "Libri"(id)
		ON DELETE CASCADE
		);
		
		-- =============================================================================
		-- Tabella ConsigliLibri
		-- Gestisce i suggerimenti: Utente U suggerisce Libro B dato il Libro A.
		-- =============================================================================
		CREATE TABLE "ConsigliLibri" (
		id                      SERIAL PRIMARY KEY,
		userid                  VARCHAR(50) NOT NULL,
		libro_sorgente_id       INTEGER NOT NULL, -- Il libro che si sta visualizzando
		libro_consigliato_id    INTEGER NOT NULL, -- Il libro suggerito
		
		CONSTRAINT unique_consiglio UNIQUE(userid, libro_sorgente_id, libro_consigliato_id),
		
		CONSTRAINT fk_consiglio_utente
		FOREIGN KEY (userid) REFERENCES "UtentiRegistrati"(userid)
		ON DELETE CASCADE,
		
		CONSTRAINT fk_libro_sorgente
		FOREIGN KEY (libro_sorgente_id) REFERENCES "Libri"(id)
		ON DELETE CASCADE,
		
		CONSTRAINT fk_libro_consigliato
		FOREIGN KEY (libro_consigliato_id) REFERENCES "Libri"(id)
		ON DELETE CASCADE
		);
		
		-- Vincolo "max 3 libri suggeriti per libro corrente e il libro deve essere in una tua libreria"
		CREATE OR REPLACE FUNCTION public.check_consigli_libri()
		RETURNS trigger
		LANGUAGE plpgsql
		AS $function$
		BEGIN
		IF (
		SELECT COUNT(*) FROM "ConsigliLibri"
		WHERE userid = NEW.userid AND
		libro_sorgente_id = NEW.libro_sorgente_id
		) >= 3
		-- Questa condizione fa rispettare anche il vincolo "libro_sorgente_id <> libro_consigliato_id"
		OR (
		SELECT COUNT(DISTINCT lxl.libro_id)
		FROM "Librerie" as l JOIN "LibriXLibrerie" AS lxl ON l.id = lxl.libreria_id
		WHERE l.userid = NEW.userid AND
		lxl.libro_id IN (NEW.libro_sorgente_id, NEW.libro_consigliato_id)
		) < 2 THEN
		RAISE EXCEPTION 'Il check tabella ConsigliLibri ha fallito';
		END IF;
		RETURN NEW;
		END;
		$function$;
		
		-- Crea il trigger per la funzione definita prima
		CREATE TRIGGER check_table
		BEFORE INSERT OR UPDATE ON "ConsigliLibri"
		FOR EACH ROW
		EXECUTE FUNCTION public.check_consigli_libri();
		
		-- Funzione di utility che conta quante volte un libro appare nella libreria di un utente
		CREATE OR REPLACE FUNCTION public.count_libri_in_librerie(uid character varying, bid integer)
		RETURNS bigint
		LANGUAGE plpgsql
		AS $function$
		BEGIN
		RETURN (
		SELECT COUNT(lxl.libro_id)
		FROM "Librerie" as l JOIN "LibriXLibrerie" AS lxl ON l.id = lxl.libreria_id
		WHERE l.userid = uid AND
		lxl.libro_id = bid
		);
		END;
		$function$;
		
		-- Elimina valutazioni o consigliati di libri che non sono piu in nessuna libreria
		CREATE OR REPLACE FUNCTION public.check_delete_libri_x_librerie()
		RETURNS trigger
		LANGUAGE plpgsql
		AS $function$
		DECLARE uid varchar(50);
		BEGIN
		-- Salvo l'userid del proprietario della libreria
		SELECT userid INTO uid
		FROM "Librerie"
		WHERE id = OLD.libreria_id;
		
		-- Se il libro non e presente in nessun'altra libreria elimina valutazioni e consigliati associati
		IF count_libri_in_librerie(uid, OLD.libro_id) <= 1 THEN
		DELETE FROM "ValutazioniLibri"
		WHERE userid = uid AND libro_id = OLD.libro_id;
		DELETE FROM "ConsigliLibri"
		WHERE userid = uid AND OLD.libro_id IN (libro_sorgente_id, libro_consigliato_id);
		END IF;
		
		RETURN OLD;
		END;
		$function$;
		
		-- Crea il trigger per la funzione definita prima
		CREATE TRIGGER check_table
		BEFORE delete ON "LibriXLibrerie"
		FOR EACH ROW
		EXECUTE FUNCTION public.check_delete_libri_x_librerie();
		
		-- Elimina ogni libro dalla libreria in questione prima di eliminare se stessa
		CREATE OR REPLACE FUNCTION public.check_delete_librerie()
		RETURNS trigger
		LANGUAGE plpgsql
		AS $function$
		BEGIN
		DELETE FROM "LibriXLibrerie" WHERE libreria_id = OLD.id;
		RETURN OLD;
		END;
		$function$;
		
		-- Crea il trigger per la funzione definita prima
		CREATE TRIGGER check_table
		BEFORE delete ON "Librerie"
		FOR EACH ROW
		EXECUTE FUNCTION public.check_delete_librerie();
		
		-- Vincolo "il libro deve essere in una tua libreria"
		CREATE OR REPLACE FUNCTION public.check_valutazioni_libri()
		RETURNS trigger
		LANGUAGE plpgsql
		AS $function$
		BEGIN
		IF count_libri_in_librerie(NEW.userid, NEW.libro_id) < 1 THEN
		RAISE EXCEPTION 'Il check tabella ValutazioniLibri ha fallito';
		END IF;
		
		RETURN NEW;
		END;
		$function$;
		
		-- Crea il trigger per la funzione definita prima
		CREATE TRIGGER check_table
		BEFORE INSERT OR UPDATE ON "ValutazioniLibri"
		FOR EACH ROW
		EXECUTE FUNCTION public.check_valutazioni_libri();
	\end{lstlisting}
	
	\subsection{Query SQL per Funzionamento del Codice}
	
	Di seguito sono riportate le query SQL utilizzate all'interno delle classi Java del modulo Server (\texttt{AuthQueries}, \texttt{BookQueries}, \texttt{LibraryQueries}, \texttt{RatingQueries}, \texttt{SuggestionQueries}). 
	Le query sono parametrizzate (uso di \texttt{?}) per essere eseguite tramite \texttt{PreparedStatement}, garantendo sicurezza contro SQL Injection e migliori performance.
	
	\begin{lstlisting}[style=sqlstyle, caption=Raccolta delle Query CRUD utilizzate nel Backend]
		-- =============================================================================
		-- AUTH QUERIES
		-- =============================================================================
		
		-- register()
		-- Controllo duplicati per registrazione utente
		SELECT
		EXISTS(SELECT 1 FROM "UtentiRegistrati" WHERE userid = ?) AS uid_ex,
		EXISTS(SELECT 1 FROM "UtentiRegistrati" WHERE codice_fiscale = ?) AS cf_ex,
		EXISTS(SELECT 1 FROM "UtentiRegistrati" WHERE email = ?) AS email_ex;
		
		-- Registrazione
		INSERT INTO "UtentiRegistrati" (userid, nome, cognome, codice_fiscale, email, password_hash)
		VALUES (?, ?, ?, ?, ?, crypt(?, gen_salt('bf')));
		
		-- login()
		-- Verifica login
		SELECT CASE
		-- 0: L'utente non esiste
		WHEN NOT EXISTS(
		SELECT 1 FROM "UtentiRegistrati"
		WHERE userid = ?
		) THEN 0
		-- 1: Se la password non e corretta
		WHEN NOT EXISTS(
		SELECT 1 FROM "UtentiRegistrati"
		WHERE userid = ? AND password_hash = crypt(?, password_hash)
		) THEN 1
		-- 2: Se l'utente esiste e la password e corretta
		ELSE 2
		END AS r;
		
		-- =============================================================================
		-- BOOK QUERIES
		-- =============================================================================
		
		-- getBookInfo()
		-- Recupero informazioni di un libro
		SELECT * FROM "Libri" WHERE id = ?;
		
		-- Recupero valutazioni di un libro
		SELECT * FROM "ValutazioniLibri" WHERE libro_id = ?;
		
		-- Recupero consigliati di un libro
		SELECT * FROM "ConsigliLibri" WHERE libro_sorgente_id = ?;
		
		-- Calcolo media valutazioni di un libro
		SELECT
		COUNT(*) as count,
		ROUND(AVG(stile), 1) AS stile,
		ROUND(AVG(contenuto), 1) AS contenuto,
		ROUND(AVG(gradevolezza), 1) AS gradevolezza,
		ROUND(AVG(originalita), 1) AS originalita,
		ROUND(AVG(edizione), 1) AS edizione,
		ROUND(AVG(finale), 1) AS finale
		FROM "ValutazioniLibri"
		WHERE libro_id = ?;
		
		-- Calcolo top consigliati di un libro
		SELECT
		l.*,
		cl.count AS count
		FROM "Libri" AS l
		JOIN (
		SELECT
		libro_consigliato_id,
		COUNT(*) AS count
		FROM "ConsigliLibri"
		WHERE libro_sorgente_id = ?
		GROUP BY libro_consigliato_id
		) AS cl
		ON l.id = cl.libro_consigliato_id
		ORDER BY count;
		
		-- selectAll()
		-- Recupera le informazioni di tutti i libri
		SELECT * FROM "Libri";
		
		-- searchByTitle()
		-- Ricerca di un libro per titolo
		SELECT * FROM "Libri" WHERE titolo ILIKE '%'||?||'%';
		
		-- searchByAuthor()
		-- Ricerca di un libro per autore
		SELECT * FROM "Libri" WHERE autori ILIKE '%'||?||'%';
		
		-- searchByAuthorAndYear()
		-- Ricerca di un libro per autore e anno
		SELECT * FROM "Libri" WHERE autori ILIKE '%'||?||'%' AND anno_pubblicazione = ?;
		
		-- =============================================================================
		-- LIBRARY QUERIES
		-- =============================================================================
		
		-- getLibrerieFrom()
		-- Recupero delle librerie da un utente
		SELECT * FROM "Librerie" WHERE userid = ?;
		
		-- getLibriFromLibreria()
		-- Recupero dei libri presenti in una libreria
		SELECT * FROM "Libri" AS l
		JOIN "LibriXLibrerie" AS lxl ON l.id = lxl.libro_id
		WHERE lxl.libreria_id = ?;
		
		-- createLibrary()
		-- Controlla se una libreria esiste gia
		SELECT CASE WHEN EXISTS(
		SELECT 1 FROM "Librerie"
		WHERE userid = ? AND nome = ?
		) THEN 1 ELSE 0
		END AS r;
		
		-- Crea una libreria
		INSERT INTO "Librerie" (nome, userid) VALUES (?, ?);
		
		-- deleteLibrary()
		-- Controlla se una libreria esiste
		SELECT CASE WHEN EXISTS(
		SELECT 1 FROM "Librerie"
		WHERE userid = ? AND id = ?
		) THEN 1 ELSE 0
		END AS r;
		
		-- Elimina una libreria
		DELETE FROM "Librerie" WHERE id = ?;
		
		-- addBookToLibrary()
		-- Controlla se una libreria esiste o se il libro e gia nella libreria
		SELECT CASE
		-- 0: La libreria non esiste
		WHEN NOT EXISTS (
		SELECT 1 FROM "Librerie"
		WHERE id = ? AND userid = ?
		) THEN 0
		-- 1: La libreria esiste ma contiene gia il libro
		WHEN EXISTS (
		SELECT 1 FROM "LibriXLibrerie"
		WHERE libreria_id = ? AND libro_id = ?
		) THEN 1
		-- 2: La libreria esiste e non contiene il libro
		ELSE 2
		END AS r;
		
		-- Aggiunge un libro a una libreria
		INSERT INTO "LibriXLibrerie" (libro_id, libreria_id) VALUES (?, ?);
		
		-- removeBookFromLibrary()
		-- Controlla se una libreria esiste o se un libro non e gia nella libreria
		SELECT CASE
		-- 0: La libreria non esiste
		WHEN NOT EXISTS (
		SELECT 1 FROM "Librerie"
		WHERE id = ? AND userid = ?
		) THEN 0
		-- 1: La libreria esiste ma non contiene il libro
		WHEN NOT EXISTS (
		SELECT 1 FROM "LibriXLibrerie"
		WHERE libreria_id = ? AND libro_id = ?
		) THEN 1
		-- 2: La libreria esiste e contiene il libro
		ELSE 2
		END AS r;
		
		-- Rimuove un libro da una libreria
		DELETE FROM "LibriXLibrerie" WHERE libro_id = ? AND libreria_id = ?;
		
		-- =============================================================================
		-- RATING QUERIES
		-- =============================================================================
		
		-- getRatingFrom()
		-- Recupera la valutazione fatte da un utente per un libro
		SELECT * FROM "ValutazioniLibri"
		WHERE userid = ? AND libro_id = ?;
		
		-- createRating()
		-- Controlla se un libro e gia stato valutato da un utente o se quell'utente 
		-- ha quel libro in una delle sue librerie
		SELECT CASE
		-- 0: Se esiste gia una valutazione per quel libro
		WHEN EXISTS(
		SELECT 1 FROM "ValutazioniLibri"
		WHERE userid = ? AND libro_id = ?
		) THEN 0
		-- 1: Se il libro sorgente non e in nessuna libreria
		WHEN count_libri_in_librerie(?, ?) = 0 THEN 1
		-- 2: Se il libro e in una libreria e non e stato valutato
		ELSE 2
		END AS r;
		
		-- Aggiunge una valutazione
		INSERT INTO "ValutazioniLibri" (
		userid, libro_id,
		stile, contenuto, gradevolezza, originalita, edizione,
		note_stile, note_contenuto, note_gradevolezza, 
		note_originalita, note_edizione, note_finale
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
		
		-- deleteRating()
		-- Controlla se un libro e stato valutato
		SELECT CASE
		-- Se il libro non ha una valutazione
		WHEN NOT EXISTS(
		SELECT 1 FROM "ValutazioniLibri"
		WHERE userid = ? AND libro_id = ?
		) THEN 0
		-- Se il libro ha una valutazione
		ELSE 1
		END AS r;
		
		-- Elimina una valutazione
		DELETE FROM "ValutazioniLibri" WHERE userid = ? AND libro_id = ?;
		
		-- =============================================================================
		-- SUGGESTION QUERIES
		-- =============================================================================
		
		-- getSuggestionsFrom()
		-- Recupera tutti i consigliati per un libro
		SELECT * FROM "ConsigliLibri"
		WHERE userid = ? AND libro_sorgente_id = ?;
		
		-- createSuggestion()
		-- Controlla se i libri coinvolti sono in una libreria dell'utente, 
		-- se esiste un'associazione e se il libro ha gia 3 consigliati
		SELECT CASE
		-- 0: Se il libro sorgente non e in nessuna libreria
		WHEN count_libri_in_librerie(?, ?) = 0 THEN 0
		-- 1: Se il libro consigliato non e in nessuna libreria
		WHEN count_libri_in_librerie(?, ?) = 0 THEN 1
		-- 2: Se esiste gia un consiglio identico
		WHEN EXISTS(
		SELECT 1 FROM "ConsigliLibri"
		WHERE userid = ? AND libro_sorgente_id = ? AND libro_consigliato_id = ?
		) THEN 2
		-- 3: Se ci sono gia 3 consigliati
		WHEN (
		SELECT COUNT(*) FROM "ConsigliLibri"
		WHERE userid = ? AND libro_sorgente_id = ?
		) >= 3 THEN 3
		-- 4: Se e tutto okay per l'aggiunta di un consigliato
		ELSE 4
		END AS r;
		
		-- Crea un nuovo consiglio
		INSERT INTO "ConsigliLibri" (userid, libro_sorgente_id, libro_consigliato_id) 
		VALUES (?, ?, ?);
		
		-- deleteSuggestion()
		-- Controlla se un utente ha consigliato un libro per un altro libro
		SELECT CASE WHEN EXISTS(
		SELECT 1 FROM "ConsigliLibri"
		WHERE userid = ? AND libro_sorgente_id = ? AND libro_consigliato_id = ?
		) THEN 1 ELSE 0
		END AS r;
		
		-- Elimina un consiglio
		DELETE FROM "ConsigliLibri"
		WHERE userid = ? AND libro_sorgente_id = ? AND libro_consigliato_id = ?;
		
		-- =============================================================================
		-- USER QUERIES
		-- =============================================================================
		
		-- getUserInfo()
		-- Recupera le informazioni di un utente
		SELECT * FROM "UtentiRegistrati" WHERE userid = ?;
	\end{lstlisting}


	\chapter{Report Tecnico della Soluzione Sviluppata}
	In questa sezione vengono dettagliate le scelte implementative, i design pattern adottati per risolvere specifici problemi architetturali e le ottimizzazioni algoritmiche utilizzate.
	
	\section{Requisiti e Ambiente di Sviluppo}
	Le seguenti versioni software sono state utilizzate per lo sviluppo e il build del progetto, come definito nei file \texttt{pom.xml} dei vari moduli Maven:
	
	\begin{center}
		\begin{tabular}{|l|l|}
			\hline
			\textbf{Componente} & \textbf{Versione} \\ \hline
			Java JDK & 25 \\ \hline
			PostgreSQL Driver & 42.7.8 \\ \hline
			JavaFX & 25.0.1 \\ \hline
			Maven Compiler & 3.14.1 \\ \hline
		\end{tabular}
	\end{center}
	
	\section{Scelte Architetturali}
	Il sistema \textit{Book Recommender} adotta un'architettura distribuita basata sul middleware \textbf{Java RMI} (Remote Method Invocation), che permette di invocare metodi su oggetti residenti in una Java Virtual Machine (JVM) diversa da quella del chiamante.
	
	Una scelta architetturale critica è stata la separazione delle interfacce nel modulo \texttt{Common}: questo permette al Client di conoscere i metodi invocabili (il "contratto") senza avere accesso al codice sorgente dell'implementazione server.
	
	\subsection{Strategia di Gestione degli Errori e Protocollo Applicativo}
	Per la comunicazione degli esiti delle operazioni tra Server e Client, è stato deciso di non utilizzare le Eccezioni Java (se non per errori critici di rete RMI), preferendo un approccio basato su \textbf{Enum}.
	
	Ogni operazione (es. Login, Creazione Libreria) restituisce un Enum specifico (es. \texttt{LoginResult}) che codifica tutti i possibili stati logici (Successo, Password Errata, Utente non Trovato).
	
	\section{Gestione del Build e Gestione delle Dipendenze}
	Il progetto adotta una struttura \textbf{Maven Multi-Module} per garantire la separazione delle responsabilità. La configurazione è definita in un \texttt{pom.xml} padre che orchestra quattro moduli figli:
	
	\begin{itemize}
		\item \textbf{common:} Contiene le interfacce RMI, i DTO e gli Enum. È una dipendenza sia del Client che del Server.
		\item \textbf{serverBR:} Dipende da \texttt{common} e dai driver PostgreSQL per la comunicazione con il DB.
		\item \textbf{clientBR:} Dipende da \texttt{common} e dalle librerie JavaFX. Utilizza i plugin specifici di JavaFX per la gestione dei moduli grafici.
		\item \textbf{db\_init:} Modulo di utilità per il setup iniziale, separato dal server per separare la logica di popolamento DB dal server. Dipende da \texttt{common} e da \texttt{serverBR} per la comunicazione con il DB.
	\end{itemize}
	
	Questa struttura impedisce, ad esempio, che il Client possa accidentalmente accedere alle classi di connessione al Database, poiché non ha il modulo \texttt{serverBR} tra le dipendenze.
	
	\subsection{Documentazione Javadoc}
	In conformità con le specifiche di progetto, l'intero codice sorgente è stato commentato seguendo lo standard Javadoc. La documentazione HTML è stata generata automaticamente tramite il plugin Maven \texttt{maven-javadoc-plugin} (configurato nel \texttt{pom.xml} padre).
	
	\subsubsection{Modularizzazione e Visibilità Javadoc}
	Una scelta tecnica rilevante è stata l'adozione del \textit{Java Platform Module System} (JPMS), introdotto da Java 9 e pienamente supportato dalla versione 25 utilizzata. 
	Ogni modulo Maven (\texttt{common}, \texttt{server}, \texttt{client}) contiene un descrittore \texttt{module-info.java}.
	
	Questa architettura influenza direttamente la generazione della documentazione Javadoc e la sicurezza del codice:
	\begin{itemize}
		\item \textbf{Incapsulamento Forte:} Solo i package esplicitamente marcati con la direttiva \texttt{exports} nel file \\\texttt{module-info.java} sono visibili agli altri moduli e inclusi nella documentazione Javadoc pubblica.
		\item \textbf{Esempio Pratico:} Nel modulo \texttt{common}, il package \texttt{com.bookrecommender.common.dto} è esportato affinché Client e Server possano scambiarsi i dati, ed è quindi documentato. Le classi interne di utilità non esportate rimangono nascoste, mantenendo pulita l'API pubblica documentata.
	\end{itemize}
	
	\begin{lstlisting}[language=Java, caption=Esempio di module-info.java nel modulo Common]
		module com.bookrecommender.common {
			requires java.rmi;
			requires java.sql;
			// Espone i DTO e le interfacce RMI alla documentazione e agli altri moduli
			exports com.bookrecommender.common.dto;
			exports com.bookrecommender.common;
			exports com.bookrecommender.common.enums.auth;
			// ... altri exports
		}
	\end{lstlisting}
	
	La documentazione completa è consultabile dal file "\texttt{target/reports/apidocs/index.html}".
	
	\section{Script di Avvio e Automazione}
	Per facilitare il deployment e l'esecuzione dei vari moduli del sistema distribuito, sono stati predisposti degli script di avvio automatizzati nella root del progetto.
	Al fine di garantire la portabilità su diversi sistemi operativi, per ogni componente è stata fornita una doppia versione dello script:
	\begin{itemize}
		\item \textbf{.bat (Windows Batch File):} Per ambienti Microsoft Windows.
		\item \textbf{.sh (Shell Script):} Per ambienti Unix-like (Linux, macOS).
	\end{itemize}
	
	L'utilizzo di questi script astrae la complessità dei comandi di avvio (come la definizione del \textit{classpath} o la gestione del \textit{module-path} di JavaFX), permettendo l'esecuzione dei moduli con un singolo click o comando da terminale.
	
	Gli script devono essere eseguiti nel seguente ordine logico per garantire il corretto funzionamento del sistema distribuito:
	
	\begin{enumerate}
		\item \textbf{\texttt{InitDB.bat / .sh}}: Esegue il modulo \texttt{db\_init}. 
		Questo script si occupa di compilare il progetto, connettersi al database PostgreSQL (utilizzando le credenziali configurate), creare lo schema delle tabelle e popolare i dati iniziali dal dataset CSV. Deve essere eseguito \textit{una tantum} o quando si desidera resettare lo stato del database.
		
		\item \textbf{\texttt{Server.bat / .sh}}: Esegue il modulo \texttt{serverBR}.
		Avvia il registro RMI sulla porta 1099 e pubblica il servizio \texttt{BookRecommenderService}, mettendosi in ascolto per le connessioni in ingresso. Questo processo deve rimanere attivo affinché l'applicazione sia utilizzabile.
		
		\item \textbf{\texttt{Client.bat / .sh}}: Esegue il modulo \texttt{clientBR}.
		Lancia l'interfaccia grafica JavaFX. Possono essere avviate molteplici istanze di questo script contemporaneamente per simulare l'accesso concorrente di più utenti al sistema.
	\end{enumerate}
	
	\section{Design Pattern Utilizzati}
	Per garantire un codice modulare, manutenibile e robusto, sono stati applicati diversi design pattern.
	
	\subsection{Pattern Singleton}
	Il pattern Singleton è stato utilizzato nella classe \texttt{DatabaseManager} (lato Server) e nella classe \texttt{App} (lato Client).
	\begin{itemize}
		\item \textbf{Scopo:} Garantire che esista una e una sola istanza della connessione al database (Server) o del gestore delle scene (Client) per tutto il ciclo di vita dell'applicazione.
		\item \textbf{Implementazione:} Il costruttore è reso privato e l'accesso all'istanza avviene tramite un metodo statico sincronizzato.
	\end{itemize}
	
	\begin{lstlisting}[language=Java, caption=Implementazione Singleton in DatabaseManager.java]
		public class DatabaseManager {
			private static DatabaseManager instance;
			private Connection pgsqlConn;
			
			private DatabaseManager() {
				// Inizializzazione driver e connessione JDBC
			}
			
			public static synchronized DatabaseManager getInstance() {
				if (instance == null) {
					instance = new DatabaseManager();
				}
				return instance;
			}
		}
	\end{lstlisting}
	
	\subsection{Pattern Data Transfer Object (DTO)}
	I DTO sono stati impiegati per il trasferimento dei dati tra Client e Server. Le classi \texttt{Libri}, \texttt{UtentiRegistrati} e \texttt{Valutazione} (nel package \texttt{common.dto}) ne sono l'esempio.
	\begin{itemize}
		\item \textbf{Caratteristiche:} Sono classi "povere" di logica, serializzabili (\texttt{implements Serializable}) e immutabili (campi \texttt{final}), progettate esclusivamente per trasportare dati attraverso la rete.
		\item \textbf{Vantaggio:} Riducono il numero di chiamate remote permettendo di inviare interi grafi di oggetti in un'unica invocazione.
	\end{itemize}
	
	\subsection{Pattern Factory e Session Object}
	Il sistema implementa una gestione delle sessioni basata su oggetti remoti dinamici.
	\begin{itemize}
		\item \textbf{Funzionamento:} La classe \texttt{BookRepositoryImpl} (nel caso di registrazione o login) agisce come una \textit{Factory}. I metodi \texttt{register} e \texttt{login}, in caso di successo, istanziano e restituiscono un nuovo oggetto \\\texttt{AuthedBookRepositoryImpl}.
		\item \textbf{Sessione:} L'oggetto restituito incapsula lo stato della sessione (l'ID dell'utente), garantendo che tutte le chiamate successive siano automaticamente autenticate.
	\end{itemize}
	
	\begin{lstlisting}[language=Java, caption=Creazione dinamica della Sessione (BookRepositoryImpl.java)]
		@Override
		public BRPair<LoginResult, AuthedBookRepositoryService> login(String userid, String pass) throws RemoteException {
			LoginResult result = AuthQueries.login(userid, pass);
			return new BRPair<>(
			result,
			// Se login OK, crea il nuovo oggetto remoto di sessione
			result == LoginResult.OK
			? new AuthedBookRepositoryImpl(userid)
			: null
			);
		}
	\end{lstlisting}
	
	\subsection{Pattern MVC (Model-View-Controller)}
	Lato Client, l'applicazione JavaFX segue il pattern MVC:
	\begin{itemize}
		\item \textbf{View:} Definita nei file \texttt{.fxml} (es. \texttt{Login.fxml}).
		\item \textbf{Controller:} Gestisce gli eventi (es. \texttt{LoginController.java}).
		\item \textbf{Model:} I dati sono rappresentati dai DTO ricevuti dal server (es. \texttt{LoginResult} e \\\texttt{AuthedBookRepositoryService}).
	\end{itemize}
	
	\section{Strutture Dati e Algoritmi}
	
	\subsection{Strutture Dati}
	\begin{itemize}
		\item \textbf{LinkedList:} Utilizzata nella classe \texttt{DatabaseManager} per accumulare i risultati delle query. È stata preferita all'\texttt{ArrayList} per la sua efficienza nelle operazioni di inserimento in coda durante la lettura sequenziale del \texttt{ResultSet}.
		\item \textbf{Java Record (BRPair):} È stata introdotta la classe generica \texttt{BRPair<A, B>} (implementata come \texttt{record} Java) per gestire il ritorno di valori multipli dai metodi RMI (es. Esito Operazione + Oggetto Remoto).
	\end{itemize}
	
	\subsection{Algoritmi e Ottimizzazioni}
	
	\subsubsection{Hashing Sicuro delle Password}
	La sicurezza non è gestita tramite algoritmi Java lato applicativo, ma delegata al DBMS tramite l'estensione \texttt{pgcrypto}.
	L'algoritmo utilizzato è \textbf{Blowfish} (tramite \texttt{bf} salt), che è molto resistente agli attacchi di forza bruta.
	\begin{lstlisting}[language=SQL, caption=Hashing in AuthQueries.java]
		INSERT INTO "UtentiRegistrati" (...) 
		VALUES (..., crypt(?, gen_salt('bf')))
	\end{lstlisting}
	
	\subsubsection{Bulk Loading del Dataset (Importazione Massiva)}
	Per il popolamento iniziale del catalogo libri (file CSV), non viene eseguito un loop di \texttt{INSERT} (che sarebbe lento a causa dell'overhead di rete per ogni riga).
	È stato implementato l'algoritmo di \textbf{Copy Manager} di PostgreSQL Driver, che apre uno stream diretto verso il server DB.
	\begin{lstlisting}[language=Java, caption=Ottimizzazione importazione CSV (Main.java)]
		CopyManager copyManager = ((PGConnection) conn).getCopyAPI();
		String sql = "COPY \"Libri\" ... FROM STDIN WITH (FORMAT csv, HEADER true)";
		// Trasferimento diretto dallo stream del file al DB
		copyManager.copyIn(sql, inputStream);
	\end{lstlisting}
	Questa soluzione riduce il tempo di importazione da diversi minuti a pochi secondi per grandi dataset.
	
	\subsubsection{Ottimizzazione delle Comunicazioni di Rete}
	Un aspetto critico in un'architettura distribuita RMI è la latenza di rete. Un approccio tradizionale per l'inserimento di dati complessi (es. suggerimenti tra libri) richiederebbe più passaggi:
	\begin{enumerate}
		\item Interrogare il DB per verificare che i dati esistano.
		\item Verificare che non ci siano duplicati.
		\item Eseguire l'inserimento effettivo.
	\end{enumerate}
	Questo comporterebbe 3 chiamate separate tra Client e Server.
	
	Per risolvere questo problema, nelle classi \texttt{LibraryQueries} e \texttt{SuggestionQueries} è stata adottata una strategia di \textbf{Query Condizionale} usando il costrutto SQL \texttt{CASE WHEN}. In questo modo, tutta la logica di controllo viene eseguita direttamente dal DBMS in un'unica operazione.
	\begin{itemize}
		\item \textbf{Vantaggio:} L'operazione diventa atomica e riduce le interazioni di rete da 3 a 1.
		\item \textbf{Risultato:} Il tempo di esecuzione diminuisce sensibilmente, migliorando l'esperienza utente.
	\end{itemize}
	
	\subsection{Analisi delle Prestazioni e Ottimizzazioni}
	In questa sezione si analizzano le prestazioni delle operazioni critiche del sistema, evidenziando come le scelte architetturali influenzino i tempi di risposta più che la pura complessità algoritmica asintotica.
	
	\subsubsection{Ottimizzazione dell'Importazione Massiva}
	Per il popolamento iniziale del database (file CSV), il sistema evita l'approccio ingenuo basato su iterazioni di query \texttt{INSERT}.
	\begin{itemize}
		\item \textbf{Strategia:} Utilizzo dell'API \texttt{CopyManager} di PostgreSQL per trasferire i dati via stream diretto.
		\item \textbf{Analisi del miglioramento:} Sebbene la complessità di lettura del file rimanga lineare rispetto alla sua dimensione, il guadagno prestazionale deriva dall'\textbf{abbattimento dell'overhead di rete}. 
		Invece di eseguire $N$ richieste/risposte tra applicazione e database per $N$ libri, viene eseguita un'unica operazione di I/O. Questo riduce i tempi di importazione da minuti a pochi secondi, eliminando la latenza del protocollo TCP/IP per ogni singolo record.
	\end{itemize}
	
	\subsubsection{Ricerca e Scansione Dati}
	Le funzionalità di ricerca permettono all'utente di trovare libri filtrando per sottostringhe nel titolo o nell'autore (pattern SQL \texttt{\%query\%}).
	
	\begin{itemize}
		\item \textbf{Lato Database (Server):} L'uso del carattere jolly iniziale (\texttt{\%}) nelle query \texttt{ILIKE} obbliga il DBMS a effettuare una scansione sequenziale della tabella. 
		Il tempo di esecuzione dipende quindi linearmente dalla dimensione del dataset ($N$) e dall'efficienza interna dell'ottimizzatore di PostgreSQL nel gestire l'I/O.
		
		\item \textbf{Lato Client (Costruzione UI):} Una volta ricevuti i risultati, il Client deve mappare i DTO ricevuti in oggetti grafici per la \texttt{ListView}. Questo processo ha un costo lineare $\mathcal{O}(R)$, dove $R$ è il numero di libri restituiti dalla ricerca.
	\end{itemize}
	
	\subsubsection{Autenticazione}
	Il processo di login si compone di due fasi distinte a livello di database:
	\begin{enumerate}
		\item \textbf{Recupero Utente:} Il database ricerca la riga corrispondente allo \texttt{userid} fornito. Poiché \texttt{userid} è definito come Chiave Primaria, PostgreSQL utilizza un indice per questa operazione. Il costo computazionale è quindi logaritmico $\mathcal{O}(\log U)$, dove $U$ è il numero di utenti registrati.
		\item \textbf{Verifica Hash:} Una volta trovato il record, la funzione \texttt{crypt} verifica la password. Questa operazione ha un costo costante $\mathcal{O}(1)$ rispetto alla mole di dati nel DB, dipendente solo dal fattore di costo dell'algoritmo impostato.
	\end{enumerate}
	
	\section{Gestione dei File}
	Il progetto gestisce diverse tipologie di file, utilizzando percorsi relativi (Classpath) per garantire la portabilità su diversi sistemi operativi.
	
	\begin{itemize}
		\item \textbf{Dataset Dati (CSV):} Il file \texttt{BooksDatasetClean.csv} è collocato nella cartella \texttt{resources} del modulo \texttt{db\_init}. Viene letto tramite \texttt{getResourceAsStream()}, evitando path assoluti (es. \texttt{C:/Users/...}).
		
		\item \textbf{Script SQL:} Il file \texttt{create-tables.sql} contenente la DDL del database viene letto come stream di testo, filtrando commenti e righe vuote prima dell'esecuzione.
		
		\item \textbf{Interfacce Grafiche (FXML):} I file di layout JavaFX sono caricati dinamicamente dalla classe \texttt{App} utilizzando \texttt{FXMLLoader.load(getClass().getResource(...))}.
		
		\item \textbf{Configurazione Ambiente (.env):} È stato introdotto un meccanismo ibrido per la configurazione delle credenziali del database all'avvio del server.
		Il sistema verifica la presenza di un file \texttt{.env} nella directory di esecuzione. 
		\begin{itemize}
			\item \textbf{Caricamento Automatico:} Se il file esiste, le credenziali vengono caricate automaticamente senza input utente.
			\item \textbf{Fallback Console:} Se il file è assente, il sistema richiede le credenziali via console (come da specifiche). In questa modalità, premendo semplicemente \texttt{Invio}, vengono utilizzati i valori di default preimpostati.
		\end{itemize}
	\end{itemize}
	
	\subsection{Specifica del Formato Dataset}
	Il sistema si aspetta in input un file denominato \texttt{BooksDatasetClean.csv}. Il file deve rispettare il formato CSV, con intestazione obbligatoria:
	
	\begin{lstlisting}[language=bash, caption=Struttura del file CSV atteso]
		titolo,autori,anno_pubblicazione,editore,categorie
		"The Great Gatsby","F. Scott Fitzgerald",1925,"Scribner","Classic,Fiction"
		"1984","George Orwell",1949,"Secker & Warburg","Dystopian,Sci-Fi"
		...
	\end{lstlisting}
	
	La corrispondenza tra le colonne del CSV e le colonne della tabella database è mappata posizionalmente nel comando \texttt{COPY} eseguito durante l'inizializzazione.
	% ---------------------------------------------
	
	\newpage
	
	% CAPITOLO 3
	\chapter{Limiti della Soluzione Sviluppata}
	Nonostante l'architettura proposta soddisfi i requisiti funzionali del progetto, un'analisi della soluzione evidenzia alcuni limiti tecnici.
	
	\section{Gestione della Connessione al Database}
	Attualmente, la classe \texttt{DatabaseManager} implementa il pattern Singleton mantenendo un'unica istanza di \\\texttt{java.sql.Connection} attiva verso PostgreSQL.
	\begin{itemize}
		\item \textbf{Problema:} Sebbene i metodi siano sincronizzati per garantire la thread-safety, l'uso di una singola connessione serializza di fatto l'accesso al database. In uno scenario con molteplici utenti concorrenti, questo crea un bottleneck, aumentando i tempi di attesa per le operazioni di I/O.
		\item \textbf{Soluzione Futura:} Implementazione di un \textit{Connection Pool} per gestire un pool di connessioni riutilizzabili, permettendo l'esecuzione parallela delle query.
	\end{itemize}
	
	\section{Scalabilità e Paginazione dei Risultati}
	Le metodi di ricerca nella classe \texttt{BookQueries} (es. \texttt{searchByTitle}) restituiscono una \texttt{LinkedList<Libri>} completa contenente tutti i record trovati.
	\begin{itemize}
		\item \textbf{Problema:} In presenza di un dataset di grandi dimensioni (migliaia di libri), caricare l'intero Result Set in memoria e trasferirlo via RMI in un unico blocco può causare un elevato consumo di RAM lato Server e latenza di rete significativa.
		\item \textbf{Soluzione Futura:} Introduzione della paginazione lato server (SQL \texttt{LIMIT} e \texttt{OFFSET}) per restituire i dati a blocchi gestibili, migliorando la reattività dell'interfaccia utente.
	\end{itemize}
	
	\section{Sicurezza del Canale di Comunicazione}
	Il sistema gestisce la sicurezza delle password tramite hashing (pgcrypto), ma il canale di trasporto RMI utilizza socket standard.
	\begin{itemize}
		\item \textbf{Problema:} Il traffico di rete tra Client e Server viaggia in chiaro. Sebbene le password non siano salvate in chiaro nel DB, esse transitano sulla rete durante la fase di login/registrazione, esponendo il sistema a potenziali attacchi \textit{Man-in-the-Middle}.
		\item \textbf{Soluzione Futura:} Configurazione di RMI per utilizzare socket SSL/TLS (RMI over SSL) per cifrare l'intero canale di comunicazione.
	\end{itemize}
	
	\section{Ottimizzazione del Calcolo del Voto Finale}
	Attualmente, il punteggio complessivo di un libro è calcolato dinamicamente a runtime, aggregando le singole recensioni (Stile, Contenuto, ecc.) ogni volta che viene richiesto il dettaglio di un libro.
	\begin{itemize}
		\item \textbf{Problema:} Al crescere del numero di valutazioni, l'esecuzione ripetuta di funzioni di aggregazione SQL (\texttt{AVG}) impatta negativamente sulle performance del DBMS, aumentando la latenza per l'utente finale durante la navigazione del catalogo.
		\item \textbf{Soluzione Futura:} Si prevede di aggiungere una colonna \texttt{voto\_medio} direttamente nella tabella \texttt{Libri}, aggiornata automaticamente tramite comando SQL o processi batch ogni volta che viene inserita una nuova valutazione. Questo renderebbe la lettura del voto un'operazione immediata a costo costante.
	\end{itemize}
	
	\section{Gestione Errori nei Metodi Get}
	L'attuale implementazione dei metodi di lettura (es. getter per ID o query di ricerca) gestisce i casi di "dato non trovato" restituendo valori \texttt{null} o collezioni vuote, senza fornire un contesto dettagliato sull'esito.
	\begin{itemize}
		\item \textbf{Problema:} L'uso di valori \texttt{null} espone il Client al rischio di \texttt{NullPointerException} se i controlli non sono capillari e crea ambiguità semantica (non è chiaro se il dato non esiste o se c'è stato un errore di connessione).
		\item \textbf{Soluzione Futura:} Gestire esplicitamente la presenza o l'assenza del valore, migliorando la robustezza del codice e la chiarezza.
	\end{itemize}
	
	\newpage
	
	\begin{thebibliography}{9}
		
		\bibitem{javadoc}
		Oracle,
		\textit{Javadoc Tool Documentation},
		\url{https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html}
		
		\bibitem{rmi}
		Oracle,
		\textit{Java Remote Method Invocation (RMI) Specification},
		\url{https://docs.oracle.com/javase/8/docs/platform/rmi/spec/rmiTOC.html}
		
		\bibitem{postgresql}
		PostgreSQL Global Development Group,
		\textit{PostgreSQL 14 Documentation},
		\url{https://www.postgresql.org/docs/14/index.html}
		
		\bibitem{pgcrypto}
		PostgreSQL Modules,
		\textit{pgcrypto Extension - Cryptographic functions for PostgreSQL},
		\url{https://www.postgresql.org/docs/current/pgcrypto.html}
		
		\bibitem{javafx}
		OpenJFX,
		\textit{JavaFX Documentation},
		\url{https://openjfx.io/}
		
	\end{thebibliography}
	
\end{document}